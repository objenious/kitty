# kitty
[![Travis-CI](https://travis-ci.org/objenious/kitty.svg)](https://travis-ci.org/objenious/kitty)  [![GoDoc](https://godoc.org/github.com/objenious/kitty?status.svg)](http://godoc.org/github.com/objenious/kitty)

`go get github.com/objenious/kitty`

## Status: alpha - breaking changes might happen

Kitty is a slightly opinionated framework based on go-kit.
It's goal is to ease development of services deployed on Kubernetes (or any similar orchestration platform).

Kitty has an opinion on:
* transports: only HTTP is supported (additional transports might be added).

Kitty has no opinion on:
* logging: no logs are generated by default, you can plug your logger and it will get additional context,
* packages: kitty only imports go-kit and the standard library,
* routers: you can use any router (Gorilla Mux works out of the box, other routers can easily be plugged),
* encoding: use whatever encoding you want (JSON, messagepack, protobuf, ...),
* monitoring, metrics and tracing: use Istio or a sidecar process.

## Example

Server-side
```
kitty.NewServer().Config(kitty.Config{HTTPPort: 8081}).
  Router(gorilla.Router()).
  HTTPEndpoint(Foo, kitty.Method("POST"), kitty.Path("/foo"), kitty.Decoder(decodeFooRequest)).
  HTTPEndpoint(Bar, kitty.Method("GET"), kitty.Path("/bar")).
  Run(ctx)

// Foo is a go-kit Endpoint
func Foo(ctx context.Context, request interface{}) (interface{}, error) {
  fr := request.(fooRequest)
  return fooResponse{Message: fmt.Sprintf("Good morning %s !", fr.Name)}, nil
}

// decodeFooRequest
func decodeFooRequest(ctx context.Context, r *http.Request) (interface{}, error) {
  var request fooRequest
	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		return nil, err
	}
	return request, nil
}
```

Client-side (with circuit breaker & exponential backoff)
```
e := kitty.NewClient(
  "POST",
  "/foo",
  httptransport.EncodeJSONRequest,
  decodeFooResponse,
).Endpoint()
cb := gobreaker.NewCircuitBreaker(gobreaker.Settings{Name: "foo"})
e = circuitbreaker.Gobreaker(cb)(e)
bo := backoff.NewExponentialBackOff()
e = kittybackoff.NewBackoff(bo)(e)

```

## How-to

### Log requests

```
kitty.NewServer().
// Log as JSON
Logger(log.NewJSONLogger(log.NewSyncWriter(os.Stdout))).
// Add path and method to all log lines
LogContext("http-path", "http-method").
// Log request and response
Middlewares(kitty.LogEndpoint("request", "response"))
```

### Integrate with Istio

TBD

### Integrate liveness/readiness checks

Using github.com/heptiolabs/healthcheck:
```
health := healthcheck.NewHandler()
health.AddLivenessCheck("goroutine-threshold", healthcheck.GoroutineCountCheck(100))
health.AddReadinessCheck("database", healthcheck.DatabasePingCheck(db, 1*time.Second))

kitty.NewServer().Liveness(health.LiveEndpoint).Readiness(health.ReadyEndpoint)
```

## Requirements

Go > 1.8

## Contribution guidelines

Contributions are welcome, as long as :
* unit tests & comments are included,
* no external package is added.

## Thanks

kitty is heavily inspired by gizmo/kit (https://godoc.org/github.com/NYTimes/gizmo/server/kit).

## License

MIT - See LICENSE file
